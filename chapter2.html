<html><head><link rel="stylesheet" type="text/css" href="css/book.css"/><link rel="stylesheet" type="text/css" href="css/highlight.css"/><link rel="stylesheet" type="text/css" href="css/console.css"/><link rel="stylesheet" type="text/css" href="css/codemirror.css"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>JavaScript Básico: valores, variáveis, e controle de fluxo -- Eloquent JavaScript</title></head><body><script type="text/javascript" src="js/before.js"> </script><div class="content"><script type="text/javascript">var chapterTag = 'basics';</script><div class="navigation"><a href="chapter1.html">&lt;&lt; Previous chapter</a> | <a href="contents.html">Contents</a> | <a href="index.html">Cover</a> | <a href="chapter3.html">Next chapter &gt;&gt;</a></div><h1><span class="number">Capítulo 2: </span>JavaScript Básico: valores, variáveis, controle de fluxo</h1><div class="block"><p><a class="paragraph" href="#pf16a700" name="pf16a700"> ¶ 
</a>Dentro do mundo do computador, há apenas dados. O que não é
dado, não existe. Todos os dados são essencialmente apenas uma sequência de 
bits<a class="footref" href="#footnote1">1</a>, e assim, fundamentalmente iguais, cada pedaço de dado desempenha
o seu próprio papel. No sistema JavaScript, a maioria dos dados é nitidamente
separada em coisas chamadas <a name="key1"></a>valores. Cada valor tem um tipo, que
determina o tipo de papel que pode desempenhar. Existem seis tipos básicos de
valores: Numbers, strings, booleans, objects, functions, e valores undefined.
</p><p><a class="paragraph" href="#p2c1d45c9" name="p2c1d45c9"> ¶ </a>Para criar um valor, deve-se simplesmente invocar seu nome. Isso é muito
conveniente. Você não tem que recolher o material de construção para seus
valores, ou pagar por eles, você só liga para um e <em>woosh</em>, você
tem. Eles não são criados a partir do ar, é claro. Todo valor tem que
ser armazenado em algum lugar, e se você quiser usar um número gigantesco 
seu computador pode ficar sem memoria. Felizmente,
isso só é um problema se você precisar de toda a memoria simultaneamente.
Assim que você não usar mais o valor, ele vai se dissipar, deixando para trás apenas alguns bits.
Estes bits vão ser reciclados para a proxima geração de valores.
</p></div><hr/><div class="block"><p><a class="paragraph" href="#p19562003" name="p19562003"> ¶ </a>Valores do tipo <a name="key2"></a>número, como você deve ter deduzido, são valores numéricos.
Eles são escritos da maneira como os números geralmente são escritos:</p><pre class="code expression"><span class="atom">144</span></pre><p><a class="paragraph" href="#p1f52a0a5" name="p1f52a0a5"> ¶ </a>
Digite no console e a mesma coisa vai ser impressa na janela de saída.
O texto que você digitou deu origem a um valor numérico, o console leu e escreveu na tela. 
Neste caso, foi um exercício sem sentido, mas logo estaremos produzindo valores de forma menos simples, então é util
testá-los no console e ver o que produzuem.</p><p><a class="paragraph" href="#p80cb806" name="p80cb806"> ¶ </a>O número<code>144</code> se parece com isto em bits<a class="footref" href="#footnote2">2</a>:</p><pre class="preformatted">0100000001100010000000000000000000000000000000000000000000000000</pre><p><a class="paragraph" href="#p1b9e3d68" name="p1b9e3d68"> ¶ </a>
O número acima tem 64 bits.
<strong>Importante:</strong> Existe uma quantidade limitada de números que podem ser expressados.
Com três dígitos decimais, apenas os números de 0 a 999 podem ser escritos, que é 10<sup>3</sup> = 1000 combinações diferentes.
Com 64 dígitos binários, 2<sup>64</sup> combinações diferentes podem ser escritas.
Isto é muito mais do que 10<sup>19</sup> (a one with nineteen zeroes).</p><p><a class="paragraph" href="#p72d2d6de" name="p72d2d6de"> ¶ </a>Nem todos os números inteiros menores que 10<sup>19</sup> cabem em um número JavaScript.
Por um lado, também há números negativos, então, um dos bits deve ser usado para armazenar o sinal do número. A grande questão é que numeros
não inteiros também devem ser representados. Para fazer isto, 11 bits são usados para armazenar a posição do ponto fracional dentro do número.
</p><p><a class="paragraph" href="#p69fbfdd9" name="p69fbfdd9"> ¶ </a>Isso deixa 52 bits<a class="footref" href="#footnote3">3</a>. Qualquer número inteiro menor que 2<sup>52</sup>
(é mais do que 10<sup>15</sup>) cabe em um número JavaScript. Na maioria dos casos, 
os números que usamos ficam bem abaixo disso, então não temos que nos preocuparmos com tudo isso.
O que é bom. Eu não tenho nada em particular contra bits, mas você precisa de uma terrivel quantidade deles
para fazer qualquer coisa.
</p><p><a class="paragraph" href="#p3986de35" name="p3986de35"> ¶ </a>Números fracionarios são escritos usando um ponto.</p><pre class="code expression"><span class="atom">9.81</span></pre><p><a class="paragraph" href="#pb4a36c6" name="pb4a36c6"> ¶ 
</a>Para números muito grandes ou muito pequenos, pode-se também utilizar a notação 'científica'
pela adição de um <code>e</code>, seguido pelo expoente do número:</p><pre class="code expression"><span class="atom">2.998e8</span></pre><p><a class="paragraph" href="#p3140e007" name="p3140e007"> ¶ </a>Que é 2.998 * 10<sup>8</sup> = 299800000.</p><p><a class="paragraph" href="#pb68b1cd" name="pb68b1cd"> ¶ </a>
Cálculos com números inteiros que se encaixam em 52
bits, será sempre mais preciso. Infelizmente, cálculos com números fracionários geralmente não são.
Isso é uma vergonha, mas só causa problemas práticos em situações muito específicas.
O importante é saber que se deve tratar números fracionários como aproximações, não como valores precisos.
</p></div><hr/><div class="block"><p><a class="paragraph" href="#p355f31b3" name="p355f31b3"> ¶ </a>
O principal a se fazer com os números é a aritimética.
 Operações aritméticas tais como a adição ou multiplicação, assumir valores e produzir novos valores. 
Aqui, veja como se escreve em JavaScript:</p><pre class="code expression"><span class="atom">100</span> + <span class="atom">4</span> * <span class="atom">11</span></pre><p><a class="paragraph" href="#p5df9439a" name="p5df9439a"> ¶ </a>Os símbolos <a name="key3"></a><code>+</code> e <a name="key4"></a><code>*</code> são chamados operadores.
O primeiro representa adição e o segundo multiplicação.
Colocar um operador entre dois valores irá realizar uma operação<a name="key5"></a> e produzir um novo valor.
</p><p><a class="paragraph" href="#p40d95ac7" name="p40d95ac7"> ¶ </a>Será que o exemplo significa 'somar 4 e 100, e multiplicar o resultado por 11',
ou a multiplicação é feita antes da adição?
 Como você deve ter adivinhado, a multiplicação acontece primeiro.
 Mas, como na matemática, isto pode ser alterado com parenteses, especificando como a operação deve ser feita<a name="key6"></a>:</p><pre class="code expression">(<span class="atom">100</span> + <span class="atom">4</span>) * <span class="atom">11</span></pre><p><a class="paragraph" href="#p50d8329c" name="p50d8329c"> ¶ </a>
 Para subtração, existe o operador <a name="key7"></a><code>-</code> , e para divisão <a name="key8"></a><code>/</code>.
 Quando os operadores aparecem juntos sem parênteses, a ordem na qual eles são aplicados é determinada pela <a name="key9"></a>precendência dos operadores.
 O primeiro exemplo mostra que a multiplicação tem uma procedência maior que a adição.
 Divisão e multiplicação vêm sempre antes de subtraçã e adição.
 Quando múltiplos operadores com a mesma precedência aparecerem lado a lado (<code>1 - 1 + 1</code>) então eles são executados da esquerda para a direita.
</p><p><a class="paragraph" href="#p41cb7a91" name="p41cb7a91"> ¶ </a>Tente descobrir qual o valor que esta operação produz, depois execute no console
para ver se você estava certo...</p><pre class="code expression"><span class="atom">115</span> * <span class="atom">4</span> - <span class="atom">4</span> + <span class="atom">88</span> / <span class="atom">2</span></pre><p><a class="paragraph" href="#p25c63f52" name="p25c63f52"> ¶ </a>
Estas regras de precedência não é algo que você deve se preocupar.
 Em caso de dúvida, basta adicionar parênteses.</p><p><a class="paragraph" href="#p762478e7" name="p762478e7"> ¶ </a>
 Existe um operador em aritmética que provavelmente não é muito familiar para você.
 É o simbolo <a name="key10"></a><code>%</code> que é usado para encontrar o <a name="key11"></a>resto de uma operação.
<code>X % Y</code> o resto da divisão de <code>X</code> por <code>Y</code>. Por exemplo
<code>314 % 100</code> é <code>14</code>, <code>10 % 3</code> é <code>1</code>, e <code>144 % 12</code> é <code>0</code>.
 O operador de resto tem a mesma procedência com a multiplicação e divisão.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p4a3424f8" name="p4a3424f8"> ¶ </a>
 O proximo tipo de dado é a <a name="key12"></a>string. 
 A sua utilização tão evidente quanto o tipo para números.
 Strings são usadas para representar texto.
 Strings são escritas colocando seu conteúdo entre aspas:</p><pre class="code expression"><span class="string">&quot;Remendo meu barco com goma de mascar.&quot;</span></pre><p><a class="paragraph" href="#p2578d13f" name="p2578d13f"> ¶ </a>
 Quase tudo pode ser colocado entre aspas duplas.
 Mas alguns caracteres são complicados.
 você pode imaginar que colocar aspas entre aspas pode ser dificil. Quebra de linhas 
<a name="key13"></a>quando você presionar enter, que também não pode ser colocada entre as aspas, a string tem que ficar em uma única linha.</p><p><a class="paragraph" href="#p5b134df3" name="p5b134df3"> ¶ </a>
Para poder ter tais caracteres em uma string, o seguinte truque é usado: Sempre que uma barra invertida ('<code>\</code>') é encontrada dentro do texto,
indica que o caractere que está logo depois dela, tem um significado especial. 
 Uma string depois de uma barra invertida, vai adicionar um caractere especial ao texto.
 Quando um caractere '<code>n</code>' é colocado depois de uma barra invertida, ele é interpretado como uma nova linha.
 Da mesma forma, um '<code>t</code>' depois de uma barra invertida, siginifica uma tabulação "tab character"<a class="footref" href="#footnote4">4</a>.</p><pre class="code expression"><span class="string">&quot;Essa é a primeira linha\nE essa é a segunda&quot;</span></pre><p><a class="paragraph" href="#p38a5cda" name="p38a5cda"> ¶ </a>
</p><p><a class="paragraph" href="#p69b5ec55" name="p69b5ec55"> ¶ </a>
Há situações onde você quer apenas uma barra invertida, e não um código especial.
 Se há duas barras invertidas seguidas uma da outra, elas vão entrar em colapso entre si, 
 e apenas uma será deixada como resultado:</p><pre class="code expression"><span class="string">&quot;Como um caractere de nova linha é escrito \&quot;\\n\&quot;.&quot;</span></pre></div><hr/><div class="block"><p><a class="paragraph" href="#p78af27fc" name="p78af27fc"> ¶ </a>
 Strings não podem ser dívidas, multiplicadas, ou subtraidas. O Operador <a name="key14"></a><code>+</code>
<em>pode</em> ser usado. 
Com strings, esse operador não soma, mas concatena, junta e cola duas ou mais strings: </p><pre class="code expression"><span class="string">&quot;con&quot;</span> + <span class="string">&quot;cat&quot;</span> + <span class="string">&quot;e&quot;</span> + <span class="string">&quot;na&quot;</span></pre><p><a class="paragraph" href="#p52eb7d44" name="p52eb7d44"> ¶ </a>
Há mais maneiras de manipular Strings, isto será discutido mais tarde.
</p></div><hr/><div class="block"><p><a class="paragraph" href="#p66e362e9" name="p66e362e9"> ¶ </a>
Nem todos os operadores são simbolos, alguns são palavras. Por exemplo, o operador <a name="key15"></a><code>typeof</code> , que produz uma string com o nome do tipo de valor que foi atribuido a ele.
</p><pre class="code expression">typeof <span class="atom">4.5</span></pre><p><a class="paragraph" href="#p1393153f" name="p1393153f"> ¶ </a>
Os outros operadores que vimos, todos operam com dois valores, <code>typeof</code> opera só com um. Os operadores que usam dois valores são chamados de <a name="key16"></a>operadores binários,
e aqueles que usam somente um, são chamados de <a name="key17"></a>operadores únarios.
 O <a name="key18"></a> operador de subtração pode ser usado como binário ou unário:</p><pre class="code expression">- (<span class="atom">10</span> - <span class="atom">2</span>)</pre></div><hr/><div class="block"><p><a class="paragraph" href="#p1d28c375" name="p1d28c375"> ¶ </a>
 Existem valores do tipo <a name="key19"></a>boolean. Há apenas dois deles: <a name="key20"></a><code>true</code> e <a name="key21"></a><code>false</code>. Aqui está uma maneira de produzir um valor <code>true</code>
: </p><pre class="code expression"><span class="atom">3</span> &gt; <span class="atom">2</span></pre><p><a class="paragraph" href="#p64212834" name="p64212834"> ¶ </a>E <code>false</code> pode ser produzido assim:</p><pre class="code expression"><span class="atom">3</span> &lt; <span class="atom">2</span></pre><p><a class="paragraph" href="#p3e739e44" name="p3e739e44"> ¶ </a>
Espero que você tenha visto os sinais <a name="key22"></a><code>&gt;</code> e <a name="key23"></a><code>&lt;</code> .
 Eles significam 'é maior que' e 'é menor que'. Eles são operadores binários, e o resultado da operação é um valor booleano que diz se é verdadeiro ou falso (true or false).
</p><p><a class="paragraph" href="#p2dc50e01" name="p2dc50e01"> ¶ </a>
As strings podem ser comparadas da mesma forma:</p><pre class="code expression"><span class="string">&quot;Aardvark&quot;</span> &lt; <span class="string">&quot;Zoroaster&quot;</span></pre><p><a class="paragraph" href="#p7e3e4694" name="p7e3e4694"> ¶ </a>
Ao comparar strings, JavaScript apenas compara sua quantidade de caracteres dentro da string, da esquerda para a direita. 
</p><p><a class="paragraph" href="#p16c0de67" name="p16c0de67"> ¶ </a>
Outros operadores similares são <a name="key25"></a><code>&gt;=</code> ('é maior do que ou igual a'),
<a name="key26"></a><code>&lt;=</code> (é menor do que ou igual a), <a name="key27"></a><code>==</code> ('é igual a'), e <a name="key28"></a><code>!=</code>
('não é igual a').</p><pre class="code expression"><span class="string">&quot;Gato&quot;</span> != <span class="string">&quot;Cão&quot;</span></pre><pre class="code expression"><span class="atom">5e2</span> == <span class="atom">500</span></pre></div><hr/><div class="block"><p><a class="paragraph" href="#p8cbcfe" name="p8cbcfe"> ¶ </a>
JavaScript suporta três operadores lógicos: <strong><em>E</em></strong>, <strong><em>OU</em></strong>, <strong><em>NÃO</em></strong>.
 </p><p><a class="paragraph" href="#p573b490c" name="p573b490c"> ¶ </a>
este <a name="key29"></a><!--<code>&amp;&amp;</code>--><strong>&&</strong> é o operador lógico <em><strong>E</strong></em>. É um operador binário, e seu resultado só é <code>verdadeiro</code> se seus dois valores forem
<code>verdadeiros</code>.</p><pre class="code expression"><span class="atom">true</span> &amp;&amp; <span class="atom">false</span></pre><p><a class="paragraph" href="#p212b9b68" name="p212b9b68"> ¶ </a><a name="key30"></a>Este <!--<code>||</code>--><strong>||</strong> É o operador lógico <em><strong>OU</strong></em>, e é <code>verdadeiro</code> se qualquer um dos valores for 
<code>verdadeiro</code>:</p><pre class="code expression"><span class="atom">true</span> || <span class="atom">false</span></pre><p><a class="paragraph" href="#p7168ee71" name="p7168ee71"> ¶ </a><strong><em>NÃO</em></strong> é escrito com ponto de exclamação, <a name="key31"></a><code>!</code>, é um operador unário que inverte o valor dado a ele<br/>
 <code>!verdadeiro</code> se torna <code>falso</code>, e <code>!falso</code> se torna <code>verdadeiro</code>.
 </p></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 2.1</div><div class="exercise"><pre class="code expression">((<span class="atom">4</span> &gt;= <span class="atom">6</span>) || (<span class="string">&quot;grama&quot;</span> != <span class="string">&quot;verde&quot;</span>)) &amp;&amp;
   !(((<span class="atom">12</span> * <span class="atom">2</span>) == <span class="atom">144</span>) &amp;&amp; <span class="atom">true</span>)</pre><p><a class="paragraph" href="#p168e6ad" name="p168e6ad"> ¶ </a>
   Esse bloco de código vai resultar em verdade? Para facilitar a leitura, há um monte de parênteses desnecessários lá.
   Esta versão simples significa a mesma coisa:</p><pre class="code expression">(<span class="atom">4</span> &gt;= <span class="atom">6</span> || <span class="string">&quot;grama&quot;</span> != <span class="string">&quot;verde&quot;</span>) &amp;&amp;
   !(<span class="atom">12</span> * <span class="atom">2</span> == <span class="atom">144</span> &amp;&amp; <span class="atom">true</span>)</pre></div><div class="solution"><p><a class="paragraph" href="#p7888dd02" name="p7888dd02"> ¶ </a>
   Sim, é <code>verdadeiro</code>. Você pode reduzir passo a passo, como aqui:</p><pre class="code expression">(<span class="atom">false</span> || <span class="atom">true</span>) &amp;&amp; !(<span class="atom">false</span> &amp;&amp; <span class="atom">true</span>)</pre><pre class="code expression"><span class="atom">true</span> &amp;&amp; !<span class="atom">false</span></pre><pre class="code expression"><span class="atom">true</span></pre><p><a class="paragraph" href="#p706b68a" name="p706b68a"> ¶ </a>
   Eu espero que você tenha percebido que <code>&quot;grama&quot; != &quot;verde&quot;</code> é <code>true</code>.
   A grama pode ser verde, mas não igual ao verde.</p></div></div><hr/><div class="block"><p><a class="paragraph" href="#p34222453" name="p34222453"> ¶ </a>
Não é sempre óbvio quando parênteses são necessários. Ná prática,
 <code>||</code> tem a menor procedência, depois vem <code>&amp;&amp;</code>, e então vem os operadores de comparação
(<code>&gt;</code>, <code>==</code>, et...), e, em seguida, o resto. 
Foi escolhido nesta ordem, para que seja necessário o menor numero de parênteses possível</p></div><hr/><div class="block"><p><a class="paragraph" href="#p65af5913" name="p65af5913"> ¶ </a>
Todos os exemplos até agora, foram da mesma forma de como você usaria uma calculadora de bolso. Faça algumas operações, obtenha valores e aplique estes operadores a eles para obter novos valores.
 Criar valores como este, é uma parte essencial de qualquer programa JavaScript, mas é só uma parte. 
 A parte do código que produz um valor é chamada <a name="key32"></a>expressão.
 Todo valor que está escrito diretamente (como <code>22</code> ou <code>&quot;psychoanalysis&quot;</code>) é uma expressão.
 Uma expressão entre parênteses também é uma expressão.
E um operador binário aplicado a duas expressões, ou um operador unário aplicado a uma, também são expressões.
</p><p><a class="paragraph" href="#p5b67046e" name="p5b67046e"> ¶ </a>
Há mais maneiras de construir expressões, veremos mais a frente.
</p><p><a class="paragraph" href="#p62c355c2" name="p62c355c2"> ¶ </a>
Existe uma unidade que é maior do que uma expressão. Ela é chamada de
<a name="key33"></a>declaração. Um programa é construido com uma lista de declarações.
 A maioria das declarações terminam com um <a name="key34"></a>ponto e virgula (<code>;</code>).
 O tipo mais simples de declaração é uma expressão com um ponto e virgula. 
 Isso é um programa:</p><pre class="code"><span class="atom">1</span>;
!<span class="atom">false</span>;</pre><p><a class="paragraph" href="#p29a7e8db" name="p29a7e8db"> ¶ </a>
É um programa inútil. Uma expressão pode se contentar em produzir apenas um valor, mas uma única declaração equivale a algo que de alguma forma pode se mudar o mundo.
 Poderia imprimir algo na tela ― que conta como mudar o mundo ― ou poderia mudar o estado interno do programa, que afetaria outras declarações que vem depois. 
 Essas mudanças são chamadas de '<a name="key35"></a>efeitos colaterais'.
 As declarações no exemplo acima apenas produzem os valores <code>1</code> e <code>true</code>, e imediatamente em seguida são reciclados<a class="footref" href="#footnote5">5</a>. Isso não diz nada sobre o mundo, e não é um efeito colateral.
 </p></div><hr/><div class="block"><p><a class="paragraph" href="#p65170986" name="p65170986"> ¶ </a>
 Como um programa mantem um estado interno? Como se lembra das coisas? 
 Vimos como produzir novos valores a partir de valores antigos, mas isso não altera os valores antigos,
 e o novo valor tem que ser imediatamente usado ou vai se dissipar novamente.
 Para capturar e armazenar valores, JavaScript fornece uma coisa chamada <a name="key36"></a>variavel.</p><pre class="code"><span class="keyword">var</span> <span class="variable">caught</span> = <span class="atom">5</span> * <span class="atom">5</span>;</pre><p><a class="paragraph" href="#p405a34f5" name="p405a34f5"> ¶ </a>
 Uma variável sempre tem um nome, e pode apontar um valor, referenciado-se a ele.
 A declaração acima cria uma variável chamada <code>caught</code> que é usada para referenciar um número que vai ser produzido pela multiplicação de <code>5</code> por <code>5</code>.
 </p><p><a class="paragraph" href="#p6a3bce68" name="p6a3bce68"> ¶ </a>
 Após executar o programa acima, você pode digitar a palavra <code>caught</code> no console, e vai ser recuperado o valor <code>25</code> para você.
 O nome da variável é usado para buscar o seu valor. <code>caught + 1</code> também funciona.
 O nome de uma variável pode ser utilizado em uma expressão, e, assim, pode fazer parte de expressões maiores.
</p><p><a class="paragraph" href="#p47e8e505" name="p47e8e505"> ¶ </a>A palavra <a name="key37"></a><code>var</code> é usada para criar uma nova variável.
 Depois de <code>var</code>, vem o nome da variável. Os nomes de variáveis podem ser quase qualquer palavra em qualquer ordem, mas não pode incluir espaços e nem começar com um dígito.
 Dígitos podem fazer parte do nome de uma variável mas não pode ser o primeiro caractere do nome da variável, <code>catch22</code> é um nome valido.
 Os caracteres '<code>$</code>' e '<code>_</code>' também podem fazer parte de nomes de variáveis, então <code>$_$</code> pode ser o nome de uma variável.
 </p><p><a class="paragraph" href="#p223643ae" name="p223643ae"> ¶ </a>
 Se quiser que a nova variável capture um valor, que é quase sempre o caso, o operador <a name="key38"></a><code>=</code> pode ser usado para dar-lhe o resultado de uma expressão.
 </p><p><a class="paragraph" href="#p666db7fe" name="p666db7fe"> ¶ </a>Quando uma variável armazena um valor, isso não significa que ela vai armazenar esse valor para sempre.
 A qualquer momento, o operador <code>=</code> pode ser usado para dar-lhe um novo valor.
</p><pre class="code"><span class="variable">caught</span> = <span class="atom">4</span> * <span class="atom">4</span>;</pre></div><hr/><div class="block"><p><a class="paragraph" href="#p2d8c2774" name="p2d8c2774"> ¶ </a>
Você deve imaginar variáveis como tentáculos, em vez de caixas.
 Elas não <em>contem</em> valores,<em>compreenda</em> ― duas variáveis pdem se referir ao mesmo valor.
 Only the values that the program still has a hold on can be accessed by it.
 When you need to remember something, you grow a tentacle to hold on to it, or re-attach one of your existing tentacles
to a new value: To remember the amount of dollars that Luigi still owes you, you could do...</p><pre class="code"><span class="keyword">var</span> <span class="variable">luigiDebt</span> = <span class="atom">140</span>;</pre><p><a class="paragraph" href="#p1d72168c" name="p1d72168c"> ¶ </a>Then, every time Luigi pays something back, this amount can be
decremented by giving the variable a new number:</p><pre class="code"><span class="variable">luigiDebt</span> = <span class="variable">luigiDebt</span> - <span class="atom">35</span>;</pre><p><a class="paragraph" href="#p233236e8" name="p233236e8"> ¶ </a>The collection of variables and their values that exist at a given
time is called the <a name="key39"></a>environment. When a program starts up, this
environment is not empty. It always contains a number of standard
variables. When your browser loads a page, it creates a new
environment and attaches these standard values to it. The variables
created and modified by programs on that page survive until the
browser goes to a new page.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p22a73bc5" name="p22a73bc5"> ¶ </a>A lot of the values provided by the standard environment have the type
'<a name="key40"></a>function'. A function is a piece of program wrapped in a value.
Generally, this piece of program does something useful, which can be
invoked using the function value that contains it. In a browser
environment, the variable <a name="key41"></a><code>alert</code> holds a function that shows a
little dialog window with a message. It is used like this:</p><pre class="code"><span class="variable">alert</span>(<span class="string">&quot;Avocados&quot;</span>);</pre><p><a class="paragraph" href="#p2c6de2b8" name="p2c6de2b8"> ¶ </a><a name="key42"></a>Executing the code in a function is called <a name="key43"></a>invoking, calling,
or <a name="key44"></a>applying it. The notation for doing this uses parentheses. Every
expression that produces a function value can be invoked by putting
parentheses after it. In the example, the value <code>&quot;Avocados&quot;</code> is given
to the function, which uses it as the text to show in the dialog
window. Values given to functions are called <a name="key45"></a>parameters or
<a name="key46"></a>arguments. <code>alert</code> needs only one of them, but other functions might
need a different number.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p590dcad3" name="p590dcad3"> ¶ </a>Showing a dialog window is a side effect. A lot of functions are
useful because of the side effects they produce. It is also possible
for a function to produce a value, in which case it does not need to
have a side effect to be useful. For example, there is a function
<a name="key47"></a><code>Math.max</code>, which takes any number of numeric arguments and gives
back the greatest:</p><pre class="code"><span class="variable">alert</span>(<span class="variable">Math</span>.<span class="property">max</span>(<span class="atom">2</span>, <span class="atom">4</span>));</pre><p><a class="paragraph" href="#p7f3f1904" name="p7f3f1904"> ¶ </a><a name="key48"></a>When a function produces a value, it is said to <a name="key49"></a>return
it. Because things that produce values are always expressions in
JavaScript, function calls can be used as a part of bigger
expressions:</p><pre class="code"><span class="variable">alert</span>(<span class="variable">Math</span>.<span class="property">min</span>(<span class="atom">2</span>, <span class="atom">4</span>) + <span class="atom">100</span>);</pre><p><a class="paragraph" href="#p2babec3e" name="p2babec3e"> ¶ </a><a href="chapter3.html">Chapter 3</a> discusses writing your own functions.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p39889ede" name="p39889ede"> ¶ </a>As the previous examples show, <code>alert</code> can be useful for showing the
result of some expression. Clicking away all those little windows can
get on one's nerves though, so from now on we will prefer to use a
similar function, called <a name="key50"></a><code>print</code>, which does not pop up a window,
but just writes a value to the output area of the console. <code>print</code> is
not a standard JavaScript function, browsers do not provide it for
you, but it is made available by this book, so you can use it on these
pages.</p><pre class="code"><span class="variable">print</span>(<span class="string">&quot;N&quot;</span>);</pre><p><a class="paragraph" href="#p6dde07b4" name="p6dde07b4"> ¶ </a>A similar function, also provided on these pages, is <code>show</code>. While
<code>print</code> will display its argument as flat text, <a name="key51"></a><code>show</code> tries to
display it the way it would look in a program, which can give more
information about the type of the value. For example, string values
keep their quotes when given to <code>show</code>:</p><pre class="code"><span class="variable">show</span>(<span class="string">&quot;N&quot;</span>);</pre><p><a class="paragraph" href="#p5758ea97" name="p5758ea97"> ¶ </a>The standard environment provided by browsers contains a few more
functions for popping up windows. You can ask the user an OK/Cancel
question using <a name="key52"></a><code>confirm</code>. This returns a boolean, <code>true</code> if the user
presses 'OK', and <code>false</code> if he presses 'Cancel'.</p><pre class="code"><span class="variable">show</span>(<span class="variable">confirm</span>(<span class="string">&quot;Shall we, then?&quot;</span>));</pre><p><a class="paragraph" href="#p6958f95" name="p6958f95"> ¶ </a><a name="key53"></a><code>prompt</code> can be used to ask an 'open' question. The first argument
is the question, the second one is the text that the user starts with.
A line of text can be typed into the window, and the function will
return this as a string.</p><pre class="code"><span class="variable">show</span>(<span class="variable">prompt</span>(<span class="string">&quot;Tell us everything you know.&quot;</span>, <span class="string">&quot;...&quot;</span>));</pre></div><hr/><div class="block"><p><a class="paragraph" href="#p6327a1f" name="p6327a1f"> ¶ </a>It is possible to give almost every variable in the environment a new
value. This can be useful, but also dangerous. If you give <code>print</code> the
value <code>8</code>, you won't be able to print things anymore. Fortunately,
there is a big 'Reset' button on the console, which will reset the
environment to its original state.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p3ccf80f0" name="p3ccf80f0"> ¶ </a>One-line programs are not very interesting. When you put more than one
statement into a program, the statements are, predictably, executed
one at a time, from top to bottom.</p><pre class="code"><span class="keyword">var</span> <span class="variable">theNumber</span> = <span class="variable">Number</span>(<span class="variable">prompt</span>(<span class="string">&quot;Pick a number&quot;</span>, <span class="string">&quot;&quot;</span>));
<span class="variable">print</span>(<span class="string">&quot;Your number is the square root of &quot;</span> +
      (<span class="variable">theNumber</span> * <span class="variable">theNumber</span>));</pre><p><a class="paragraph" href="#p5b700f68" name="p5b700f68"> ¶ </a>The function <a name="key54"></a><code>Number</code> converts a value to a number, which is needed
in this case because the result of <code>prompt</code> is a string value. There
are similar functions called <a name="key55"></a><code>String</code> and <a name="key56"></a><code>Boolean</code> which convert
values to those types.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p1f853603" name="p1f853603"> ¶ </a>Consider a program that prints out all even numbers from 0 to 12. One
way to write this is:</p><pre class="code"><span class="variable">print</span>(<span class="atom">0</span>);
<span class="variable">print</span>(<span class="atom">2</span>);
<span class="variable">print</span>(<span class="atom">4</span>);
<span class="variable">print</span>(<span class="atom">6</span>);
<span class="variable">print</span>(<span class="atom">8</span>);
<span class="variable">print</span>(<span class="atom">10</span>);
<span class="variable">print</span>(<span class="atom">12</span>);</pre><p><a class="paragraph" href="#p587f2118" name="p587f2118"> ¶ </a>That works, but the idea of writing a program is to make something
<em>less</em> work, not more. If we needed all even numbers below 1000, the
above would be unworkable. What we need is a way to automatically
repeat some code.</p><pre class="code"><span class="keyword">var</span> <span class="variable">currentNumber</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">currentNumber</span> &lt;= <span class="atom">12</span>) {
  <span class="variable">print</span>(<span class="variable">currentNumber</span>);
  <span class="variable">currentNumber</span> = <span class="variable">currentNumber</span> + <span class="atom">2</span>;
}</pre><p><a class="paragraph" href="#p4090b34b" name="p4090b34b"> ¶ </a>You may have seen <a name="key57"></a><code>while</code> in the introduction chapter. A statement
starting with the word <code>while</code> creates a <a name="key58"></a>loop. A loop is a
disturbance in the sequence of statements ― it may cause the program to
repeat some statements multiple times. In this case, the word <code>while</code>
is followed by an expression in parentheses (the parentheses are
compulsory here), which is used to determine whether the loop will
loop or finish. As long as the boolean value produced by this
expression is <code>true</code>, the code in the loop is repeated. As soon as it
is false, the program goes to the bottom of the loop and continues as
normal.</p><p><a class="paragraph" href="#p6ad2f5e2" name="p6ad2f5e2"> ¶ </a>The variable <code>currentNumber</code> demonstrates the way a variable can track
the progress of a program. Every time the loop repeats, it is
incremented by <code>2</code>, and at the beginning of every repetition, it is
compared with the number <code>12</code> to decide whether to keep on looping.</p><p><a class="paragraph" href="#p7b49a0e7" name="p7b49a0e7"> ¶ </a>The third part of a <code>while</code> statement is another statement. This is
the <a name="key59"></a>body of the loop, the action or actions that must take place
multiple times. If we did not have to print the numbers, the program
could have been:</p><pre class="code"><span class="keyword">var</span> <span class="variable">currentNumber</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">currentNumber</span> &lt;= <span class="atom">12</span>)
  <span class="variable">currentNumber</span> = <span class="variable">currentNumber</span> + <span class="atom">2</span>;</pre><p><a class="paragraph" href="#p6519059c" name="p6519059c"> ¶ </a>Here, <code>currentNumber = currentNumber + 2;</code> is the statement that forms
the body of the loop. We must also print the number, though, so the
loop statement must consist of more than one statement. <a name="key60"></a>Braces
(<code>{</code> and <code>}</code>) are used to group statements into <a name="key61"></a>blocks. To the world
outside the block, a block counts as a single statement. In the earlier
example, this is used to include in the loop both the call to <code>print</code>
and the statement that updates <code>currentNumber</code>.</p></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 2.2</div><div class="exercise"><p><a class="paragraph" href="#p643af372" name="p643af372"> ¶ </a>Use the techniques shown so far to write a program that calculates and
shows the value of 2<sup>10</sup> (2 to the 10th power). You are, obviously, not
allowed to use a cheap trick like just writing <code>2 * 2 * ...</code>.</p><p><a class="paragraph" href="#p27b31837" name="p27b31837"> ¶ </a>If you are having trouble with this, try to see it in terms of the
even-numbers example. The program must perform an action a certain
amount of times. A counter variable with a <code>while</code> loop can be used
for that. Instead of printing the counter, the program must multiply
something by 2. This something should be another variable, in which
the result value is built up.</p><p><a class="paragraph" href="#p551ebf82" name="p551ebf82"> ¶ </a>Don't worry if you don't quite see how this would work yet. Even if
you perfectly understand all the techniques this chapter covers, it
can be hard to apply them to a specific problem. Reading and writing
code will help develop a feeling for this, so study the solution, and
try the next exercise.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">result</span> = <span class="atom">1</span>;
<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">counter</span> &lt; <span class="atom">10</span>) {
  <span class="variable">result</span> = <span class="variable">result</span> * <span class="atom">2</span>;
  <span class="variable">counter</span> = <span class="variable">counter</span> + <span class="atom">1</span>;
}
<span class="variable">show</span>(<span class="variable">result</span>);</pre><p><a class="paragraph" href="#p22444a64" name="p22444a64"> ¶ </a>The counter could also start at <code>1</code> and check for <code>&lt;= 10</code>, but, for
reasons that will become apparent later on, it is a good idea to get
used to counting from 0.</p><p><a class="paragraph" href="#p5acf5074" name="p5acf5074"> ¶ </a>Obviously, your own solutions aren't required to be precisely the same
as mine. They should work. And if they are very different, make sure
you also understand my solution.</p></div></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 2.3</div><div class="exercise"><p><a class="paragraph" href="#p500f68ef" name="p500f68ef"> ¶ </a>With some slight modifications, the solution to the previous exercise
can be made to draw a triangle. And when I say 'draw a triangle' I
mean 'print out some text that almost looks like a triangle when you
squint'.</p><p><a class="paragraph" href="#p3e5097db" name="p3e5097db"> ¶ </a>Print out ten lines. On the first line there is one '#' character. On
the second there are two. And so on.</p><p><a class="paragraph" href="#p144feabf" name="p144feabf"> ¶ </a>How does one get a string with X '#' characters in it? One way is to
build it every time it is needed with an 'inner loop' ― a loop inside
a loop. A simpler way is to reuse the string that the previous
iteration of the loop used, and add one character to it.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">line</span> = <span class="string">&quot;&quot;</span>;
<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>;
<span class="keyword">while</span> (<span class="variable">counter</span> &lt; <span class="atom">10</span>) {
  <span class="variable">line</span> = <span class="variable">line</span> + <span class="string">&quot;#&quot;</span>;
  <span class="variable">print</span>(<span class="variable">line</span>);
  <span class="variable">counter</span> = <span class="variable">counter</span> + <span class="atom">1</span>;
}</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#p16ea3e42" name="p16ea3e42"> ¶ </a>You will have noticed the spaces I put in front of some statements.
These are not required: The computer will accept the program just fine
without them. In fact, even the line breaks in programs are optional.
You could write them as a single long line if you felt like it. The
role of the <a name="key62"></a>indentation inside blocks is to make the structure of
the code clearer to a reader. Because new blocks can be opened inside
other blocks, it can become hard to see where one block ends and
another begins in a complex piece of code. When lines are indented,
the visual shape of a program corresponds to the shape of the blocks
inside it. I like to use two spaces for every open block, but tastes
differ.</p><p><a class="paragraph" href="#p2284e303" name="p2284e303"> ¶ </a>The field in the console where you can
type programs will help you by automatically adding these spaces. This
may seem annoying at first, but when you write a lot of code it
becomes a huge time-saver. Pressing the tab key will re-indent the
line your cursor is currently on.</p><p><a class="paragraph" href="#p751953db" name="p751953db"> ¶ </a>In some cases, JavaScript allows you to omit the semicolon at the end
of a statement. In other cases, it has to be there or strange things
will happen. The rules for when it can be safely omitted are complex
and weird. In this book, I won't leave out any semicolons, and I
strongly urge you to do the same in your own programs.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p5326c0b7" name="p5326c0b7"> ¶ </a>The uses of <code>while</code> we have seen so far all show the same pattern.
First, a 'counter' variable is created. This variable tracks the
progress of the loop. The <code>while</code> itself contains a check, usually to
see whether the counter has reached some boundary yet. Then, at the
end of the loop body, the counter is updated.</p><p><a class="paragraph" href="#p21769c1a" name="p21769c1a"> ¶ </a>A lot of loops fall into this pattern. For this reason, JavaScript,
and similar languages, also provide a slightly shorter and more
comprehensive form:</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">number</span> = <span class="atom">0</span>; <span class="variable">number</span> &lt;= <span class="atom">12</span>; <span class="variable">number</span> = <span class="variable">number</span> + <span class="atom">2</span>)
  <span class="variable">show</span>(<span class="variable">number</span>);</pre><p><a class="paragraph" href="#p537c4259" name="p537c4259"> ¶ </a>This program is exactly equivalent to the earlier even-number-printing
example. The only change is that all the statements that are related
to the 'state' of the loop are now on one line. The parentheses after
the <a name="key63"></a><code>for</code> should contain two semicolons. The part before the first
semicolon <em>initialises</em> the loop, usually by defining a variable. The
second part is the expression that <em>checks</em> whether the loop must
still continue. The final part <em>updates</em> the state of the loop. In
most cases this is shorter and clearer than a <code>while</code> construction.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p38d54058" name="p38d54058"> ¶ </a>I have been using some rather odd <a name="key64"></a>capitalisation in some variable
names. Because you can not have spaces in these names ― the computer
would read them as two separate variables ― your choices for a name
that is made of several words are more or less limited to the
following: <code>fuzzylittleturtle</code>, <code>fuzzy_little_turtle</code>,
<code>FuzzyLittleTurtle</code>, or <code>fuzzyLittleTurtle</code>. The first one is hard to
read. Personally, I like the one with the underscores, though it is a
little painful to type. However, the standard JavaScript functions,
and most JavaScript programmers, follow the last one. It is not hard
to get used to little things like that, so I will just follow the
crowd and capitalise the first letter of every word after the first.</p><p><a class="paragraph" href="#p4dde6b1f" name="p4dde6b1f"> ¶ </a>In a few cases, such as the <code>Number</code> function, the first letter of a
variable is also capitalised. This was done to mark this function as a
constructor. What a constructor is will become clear in <a href="chapter8.html">chapter 8</a>. For
now, the important thing is not to be bothered by this apparent lack
of consistency.</p><p><a class="paragraph" href="#p645338be" name="p645338be"> ¶ </a>Note that names that have a special meaning, such as <code>var</code>, <code>while</code>,
and <code>for</code> may not be used as variable names. These are called
<a name="key65"></a>keywords. There are also a number of <a name="key66"></a>words which
are 'reserved for use' in future versions of JavaScript. These are
also officially not allowed to be used as variable names, though some
browsers do allow them. The full list is rather long:</p><pre class="preformatted">abstract boolean break byte case catch char class const continue
debugger default delete do double else enum export extends false
final finally float for function goto if implements import in
instanceof int interface long native new null package private
protected public return short static super switch synchronized
this throw throws transient true try typeof var void volatile
while with</pre><p><a class="paragraph" href="#pd1db8a7" name="pd1db8a7"> ¶ </a>Don't worry about memorising these for now, but remember that this
might be the problem when something does not work as expected. In my
experience, <code>char</code> (to store a one-character string) and <a name="key67"></a><code>class</code> are
the most common names to accidentally use.</p></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 2.4</div><div class="exercise"><p><a class="paragraph" href="#p18ce9ce0" name="p18ce9ce0"> ¶ </a>Rewrite the solutions of the previous two exercises to use <code>for</code>
instead of <code>while</code>.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">result</span> = <span class="atom">1</span>;
<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>; <span class="variable">counter</span> &lt; <span class="atom">10</span>; <span class="variable">counter</span> = <span class="variable">counter</span> + <span class="atom">1</span>)
  <span class="variable">result</span> = <span class="variable">result</span> * <span class="atom">2</span>;
<span class="variable">show</span>(<span class="variable">result</span>);</pre><p><a class="paragraph" href="#p6b6ab35a" name="p6b6ab35a"> ¶ </a>Note that even if no block is opened with a '<code>{</code>', the statement in
the loop is still indented two spaces to make it clear that it
'belongs' to the line above it.</p><pre class="code"><span class="keyword">var</span> <span class="variable">line</span> = <span class="string">&quot;&quot;</span>;
<span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>; <span class="variable">counter</span> &lt; <span class="atom">10</span>; <span class="variable">counter</span> = <span class="variable">counter</span> + <span class="atom">1</span>) {
  <span class="variable">line</span> = <span class="variable">line</span> + <span class="string">&quot;#&quot;</span>;
  <span class="variable">print</span>(<span class="variable">line</span>);
}</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#p3e429b7d" name="p3e429b7d"> ¶ </a><a name="key68"></a><a name="key69"></a><a name="key70"></a><a name="key71"></a>A program often needs to 'update' a
variable with a value that is based on its previous value. For example
<code>counter = counter + 1</code>. JavaScript provides a shortcut for this:
<code>counter += 1</code>. This also works for many other operators, for example
<code>result *= 2</code> to double the value of <code>result</code>, or <code>counter -= 1</code> to
count downwards.</p><p><a class="paragraph" href="#p4acc14ef" name="p4acc14ef"> ¶ </a><a name="key72"></a><a name="key73"></a>For <code>counter += 1</code> and <code>counter -= 1</code> there are even
shorter versions: <code>counter++</code> and <code>counter--</code>.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p5f3c7e54" name="p5f3c7e54"> ¶ </a>Loops are said to affect the <a name="key74"></a>control flow of a program. They change
the order in which statements are executed. In many cases, another
kind of flow is useful: skipping statements.</p><p><a class="paragraph" href="#p393a1809" name="p393a1809"> ¶ </a>We want to show all numbers below 20 which are divisible both by 3 and
by 4.</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>; <span class="variable">counter</span> &lt; <span class="atom">20</span>; <span class="variable">counter</span>++) {
  <span class="keyword">if</span> (<span class="variable">counter</span> % <span class="atom">3</span> == <span class="atom">0</span> &amp;&amp; <span class="variable">counter</span> % <span class="atom">4</span> == <span class="atom">0</span>)
    <span class="variable">show</span>(<span class="variable">counter</span>);
}</pre><p><a class="paragraph" href="#p40d2b6b6" name="p40d2b6b6"> ¶ </a>The keyword <a name="key75"></a><code>if</code> is not too different from the keyword <code>while</code>: It
checks the condition it is given (between parentheses), and executes
the statement after it based on this condition. But it does this only
once, so that the statement is executed zero or one time.</p><p><a class="paragraph" href="#p5918d8f7" name="p5918d8f7"> ¶ </a>The trick with the remainder (<a name="key76"></a><code>%</code>) operator is an easy way to test
whether a number is divisible by another number. If it is, the
remainder of their division, which is what remainder gives you, is zero.</p><p><a class="paragraph" href="#p6620cc88" name="p6620cc88"> ¶ </a>If we wanted to print all numbers below 20, but put
parentheses around the ones that are not divisible by 4, we can do it
like this:</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>; <span class="variable">counter</span> &lt; <span class="atom">20</span>; <span class="variable">counter</span>++) {
  <span class="keyword">if</span> (<span class="variable">counter</span> % <span class="atom">4</span> == <span class="atom">0</span>)
    <span class="variable">print</span>(<span class="variable">counter</span>);
  <span class="keyword">if</span> (<span class="variable">counter</span> % <span class="atom">4</span> != <span class="atom">0</span>)
    <span class="variable">print</span>(<span class="string">&quot;(&quot;</span> + <span class="variable">counter</span> + <span class="string">&quot;)&quot;</span>);
}</pre><p><a class="paragraph" href="#p5cbf1e0f" name="p5cbf1e0f"> ¶ </a>But now the program has to determine whether <code>counter</code> is divisible by
<code>4</code> two times. The same effect can be obtained by appending an <code>else</code>
part after an <code>if</code> statement. The <a name="key77"></a><code>else</code> statement is executed only
when the <code>if</code>'s condition is false.</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>; <span class="variable">counter</span> &lt; <span class="atom">20</span>; <span class="variable">counter</span>++) {
  <span class="keyword">if</span> (<span class="variable">counter</span> % <span class="atom">4</span> == <span class="atom">0</span>)
    <span class="variable">print</span>(<span class="variable">counter</span>);
  <span class="keyword">else</span>
    <span class="variable">print</span>(<span class="string">&quot;(&quot;</span> + <span class="variable">counter</span> + <span class="string">&quot;)&quot;</span>);
}</pre><p><a class="paragraph" href="#pb1e4e71" name="pb1e4e71"> ¶ </a>To stretch this trivial example a bit further, we now want to print
these same numbers, but add two stars after them when they are greater
than 15, one star when they are greater than 10 (but not greater than
15), and no stars otherwise.</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>; <span class="variable">counter</span> &lt; <span class="atom">20</span>; <span class="variable">counter</span>++) {
  <span class="keyword">if</span> (<span class="variable">counter</span> &gt; <span class="atom">15</span>)
    <span class="variable">print</span>(<span class="variable">counter</span> + <span class="string">&quot;**&quot;</span>);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">counter</span> &gt; <span class="atom">10</span>)
    <span class="variable">print</span>(<span class="variable">counter</span> + <span class="string">&quot;*&quot;</span>);
  <span class="keyword">else</span>
    <span class="variable">print</span>(<span class="variable">counter</span>);
}</pre><p><a class="paragraph" href="#p6536644" name="p6536644"> ¶ </a>This demonstrates that you can chain <code>if</code> statements together. In this
case, the program first looks if <code>counter</code> is greater than <code>15</code>. If it
is, the two stars are printed and the other tests are skipped. If it
is not, we continue to check if <code>counter</code> is greater than <code>10</code>. Only
if <code>counter</code> is also not greater than <code>10</code> does it arrive at the last
<code>print</code> statement.</p></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 2.5</div><div class="exercise"><p><a class="paragraph" href="#p60bba450" name="p60bba450"> ¶ </a>Write a program to ask yourself, using <code>prompt</code>, what the value of 2 +
2 is. If the answer is &quot;4&quot;, use <code>alert</code> to say something praising. If
it is &quot;3&quot; or &quot;5&quot;, say &quot;Almost!&quot;. In other cases, say something mean.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">answer</span> = <span class="variable">prompt</span>(<span class="string">&quot;You! What is the value of 2 + 2?&quot;</span>, <span class="string">&quot;&quot;</span>);
<span class="keyword">if</span> (<span class="variable">answer</span> == <span class="string">&quot;4&quot;</span>)
  <span class="variable">alert</span>(<span class="string">&quot;You must be a genius or something.&quot;</span>);
<span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">answer</span> == <span class="string">&quot;3&quot;</span> || <span class="variable">answer</span> == <span class="string">&quot;5&quot;</span>)
  <span class="variable">alert</span>(<span class="string">&quot;Almost!&quot;</span>);
<span class="keyword">else</span>
  <span class="variable">alert</span>(<span class="string">&quot;You're an embarrassment.&quot;</span>);</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#p7504b199" name="p7504b199"> ¶ </a>When a loop does not always have to go all the way through to its end,
the <a name="key78"></a><code>break</code> keyword can be useful. It immediately jumps out of the
current loop, continuing after it. This program finds the first number
that is greater than 20 and divisible by 7:</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">current</span> = <span class="atom">20</span>; ; <span class="variable">current</span>++) {
  <span class="keyword">if</span> (<span class="variable">current</span> % <span class="atom">7</span> == <span class="atom">0</span>)
    <span class="keyword">break</span>;
}
<span class="variable">print</span>(<span class="variable">current</span>);</pre><p><a class="paragraph" href="#p1ad637f9" name="p1ad637f9"> ¶ </a>The <code>for</code> construct shown above does not have a part that checks for
the end of the loop. This means that it is dependent on the <code>break</code>
statement inside it to ever stop. The same program could also have
been written as simply...</p><pre class="code"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="variable">current</span> = <span class="atom">20</span>; <span class="variable">current</span> % <span class="atom">7</span> != <span class="atom">0</span>; <span class="variable">current</span>++)
  ;
<span class="variable">print</span>(<span class="variable">current</span>);</pre><p><a class="paragraph" href="#p1561aa83" name="p1561aa83"> ¶ </a>In this case, the body of the loop is empty. A lone semicolon can be
used to produce an empty statement. Here, the only effect of the loop
is to increment the variable <code>current</code> to its desired value. But I
needed an example that uses <code>break</code>, so pay attention to the first
version too.</p></div><hr/><div class="block"><a name="exercise6"></a><div class="exercisenum">Ex. 2.6</div><div class="exercise"><p><a class="paragraph" href="#p4dd1131b" name="p4dd1131b"> ¶ </a>Add a <code>while</code> and optionally a <code>break</code> to your solution for the
previous exercise, so that it keeps repeating the question until a
correct answer is given.</p><p><a class="paragraph" href="#pcc8fff8" name="pcc8fff8"> ¶ </a>Note that <code>while (true) ...</code> can be used to create a loop that does
not end on its own account. This is a bit silly, you ask the program
to loop as long as <code>true</code> is <code>true</code>, but it is a useful trick.</p></div><div class="solution"><pre class="code"><span class="keyword">var</span> <span class="variable">answer</span>;
<span class="keyword">while</span> (<span class="atom">true</span>) {
  <span class="variable">answer</span> = <span class="variable">prompt</span>(<span class="string">&quot;You! What is the value of 2 + 2?&quot;</span>, <span class="string">&quot;&quot;</span>);
  <span class="keyword">if</span> (<span class="variable">answer</span> == <span class="string">&quot;4&quot;</span>) {
    <span class="variable">alert</span>(<span class="string">&quot;You must be a genius or something.&quot;</span>);
    <span class="keyword">break</span>;
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">answer</span> == <span class="string">&quot;3&quot;</span> || <span class="variable">answer</span> == <span class="string">&quot;5&quot;</span>) {
    <span class="variable">alert</span>(<span class="string">&quot;Almost!&quot;</span>);
  }
  <span class="keyword">else</span> {
    <span class="variable">alert</span>(<span class="string">&quot;You're an embarrassment.&quot;</span>);
  }
}</pre><p><a class="paragraph" href="#p77747b6" name="p77747b6"> ¶ </a>Because the first <code>if</code>'s body now has two statements, I added braces
around all the bodies. This is a matter of taste. Having an
<code>if</code>/<code>else</code> chain where some of the bodies are blocks and others are
single statements looks a bit lopsided to me, but you can make up your
own mind about that.</p><p><a class="paragraph" href="#p3f490564" name="p3f490564"> ¶ </a>Another solution, arguably nicer, but without <code>break</code>:</p><pre class="code"><span class="keyword">var</span> <span class="variable">value</span> = <span class="atom">null</span>;
<span class="keyword">while</span> (<span class="variable">value</span> != <span class="string">&quot;4&quot;</span>) {
  <span class="variable">value</span> = <span class="variable">prompt</span>(<span class="string">&quot;You! What is the value of 2 + 2?&quot;</span>, <span class="string">&quot;&quot;</span>);
  <span class="keyword">if</span> (<span class="variable">value</span> == <span class="string">&quot;4&quot;</span>)
    <span class="variable">alert</span>(<span class="string">&quot;You must be a genius or something.&quot;</span>);
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">value</span> == <span class="string">&quot;3&quot;</span> || <span class="variable">value</span> == <span class="string">&quot;5&quot;</span>)
    <span class="variable">alert</span>(<span class="string">&quot;Almost!&quot;</span>);
  <span class="keyword">else</span>
    <span class="variable">alert</span>(<span class="string">&quot;You're an embarrassment.&quot;</span>);
}</pre></div></div><hr/><div class="block"><p><a class="paragraph" href="#p2e69b3e7" name="p2e69b3e7"> ¶ </a>In the solution to the previous exercise there is a statement <code>var
answer;</code>. This creates a variable named <code>answer</code>, but does not give it
a value. What happens when you take the value of this variable?</p><pre class="code"><span class="keyword">var</span> <span class="variable">mysteryVariable</span>;
<span class="variable">show</span>(<span class="variable">mysteryVariable</span>);</pre><p><a class="paragraph" href="#p5bb576ee" name="p5bb576ee"> ¶ </a>In terms of tentacles, this variable ends in thin air, it has nothing
to grasp. When you ask for the value of an empty place, you get a
special value named <a name="key79"></a><code>undefined</code>. Functions which do not return an
interesting value, such as <code>print</code> and <code>alert</code>, also return an
<code>undefined</code> value.</p><pre class="code"><span class="variable">show</span>(<span class="variable">alert</span>(<span class="string">&quot;I am a side effect.&quot;</span>));</pre><p><a class="paragraph" href="#p9474c16" name="p9474c16"> ¶ </a>There is also a similar value, <a name="key80"></a><code>null</code>, whose meaning is 'this
variable is defined, but it does not have a value'. The difference in
meaning between <code>undefined</code> and <code>null</code> is mostly academic, and usually
not very interesting. In practical programs, it is often necessary to
check whether something 'has a value'. In these cases, the expression
<code>something == undefined</code> may be used, because, even though they are
not exactly the same value, <code>null == undefined</code> will produce <code>true</code>.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p42c1b5bc" name="p42c1b5bc"> ¶ </a>Which brings us to another tricky subject...</p><pre class="code"><span class="variable">show</span>(<span class="atom">false</span> == <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;&quot;</span> == <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;5&quot;</span> == <span class="atom">5</span>);</pre><p><a class="paragraph" href="#p128d250" name="p128d250"> ¶ </a><a name="key81"></a>All these give the value <code>true</code>. When comparing
values that have different types, JavaScript uses a complicated and
confusing set of rules. I am not going to try to explain them
precisely, but in most cases it just tries to convert one of the
values to the type of the other value. However, when <code>null</code> or
<code>undefined</code> occur, it only produces <code>true</code> if both sides are <code>null</code> or
<code>undefined</code>.</p><p><a class="paragraph" href="#p125eebb1" name="p125eebb1"> ¶ </a>What if you want to test whether a variable refers to the value
<code>false</code>? The rules for converting strings and numbers to boolean
values state that <code>0</code> and the empty string count as <code>false</code>, while all
the other values count as <code>true</code>. Because of this, the expression
<code>variable == false</code> is also <code>true</code> when <code>variable</code> refers to <code>0</code> or
<code>&quot;&quot;</code>. For cases like this, where you do <em>not</em> want any automatic type
conversions to happen, there are two extra operators: <a name="key82"></a><code>===</code> and
<a name="key83"></a><code>!==</code>. The first tests whether a value is precisely equal to the
other, and the second tests whether it is not precisely equal.</p><pre class="code"><span class="variable">show</span>(<span class="atom">null</span> === <span class="atom">undefined</span>);
<span class="variable">show</span>(<span class="atom">false</span> === <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;&quot;</span> === <span class="atom">0</span>);
<span class="variable">show</span>(<span class="string">&quot;5&quot;</span> === <span class="atom">5</span>);</pre><p><a class="paragraph" href="#p2ef5a755" name="p2ef5a755"> ¶ </a>All these are <code>false</code>.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p256d266d" name="p256d266d"> ¶ </a>Values given as the condition in an <code>if</code>, <code>while</code>, or <code>for</code> statement
do not have to be booleans. They will be automatically converted to
booleans before they are checked. This means that the number <code>0</code>, the
empty string <code>&quot;&quot;</code>, <code>null</code>, <code>undefined</code>, and of course <code>false</code>, will
all count as false.</p><p><a class="paragraph" href="#p5d56aa6e" name="p5d56aa6e"> ¶ </a>The fact that all other values are converted to <code>true</code> in this case
makes it possible to leave out explicit comparisons in many
situations. If a variable is known to contain either a string or
<code>null</code>, one could check for this very simply...</p><pre class="code"><span class="keyword">var</span> <span class="variable">maybeNull</span> = <span class="atom">null</span>;
<span class="comment">// ... mystery code that might put a string into maybeNull ...</span>
<span class="keyword">if</span> (<span class="variable">maybeNull</span>)
  <span class="variable">print</span>(<span class="string">&quot;maybeNull has a value&quot;</span>);</pre><p><a class="paragraph" href="#p263ff17d" name="p263ff17d"> ¶ </a>... except in the case where the mystery code gives <code>maybeNull</code> the
value <code>&quot;&quot;</code>. An empty string is false, so nothing is printed. Depending
on what you are trying to do, this might be <em>wrong</em>. It is often a
good idea to add an explicit <code>=== null</code> or <code>=== false</code> in cases like
this to prevent subtle mistakes. The same occurs with number values
that might be <code>0</code>.</p></div><hr/><div class="block"><p><a class="paragraph" href="#p7139d870" name="p7139d870"> ¶ </a>The line that talks about 'mystery code' in the previous example might
have looked a bit suspicious to you. It is often useful to include
extra text in a program. The most common use for this is adding some
explanations in human language to a program.</p><pre class="code"><span class="comment">// The variable counter, which is about to be defined, is going</span>
<span class="comment">// to start with a value of 0, which is zero.</span>
<span class="keyword">var</span> <span class="variable">counter</span> = <span class="atom">0</span>;
<span class="comment">// Now, we are going to loop, hold on to your hat.</span>
<span class="keyword">while</span> (<span class="variable">counter</span> &lt; <span class="atom">100</span> <span class="comment">/* counter is less than one hundred */</span>)
<span class="comment">/* Every time we loop, we INCREMENT the value of counter,
   Seriously, we just add one to it. */</span>
  <span class="variable">counter</span>++;
<span class="comment">// And then, we are done.</span></pre><p><a class="paragraph" href="#p6b2c537a" name="p6b2c537a"> ¶ </a>This kind of text is called a <a name="key84"></a>comment. The rules are like this:
'<code>/*</code>' starts a comment that goes on until a '<code>*/</code>' is found. '<code>//</code>'
starts another kind of comment, which goes on until the end of the
line.</p><p><a class="paragraph" href="#p12f4068" name="p12f4068"> ¶ </a>As you can see, even the simplest programs can be made to look big,
ugly, and complicated by simply adding a lot of comments to them.</p></div><hr/><div class="block"><p><a class="paragraph" href="#peda8c15" name="peda8c15"> ¶ </a>There are some other situations that cause automatic <a name="key85"></a>type
conversions to happen. If you add a non-string value to a string, the
value is automatically converted to a string before it is
concatenated. If you multiply a number and a string, JavaScript tries
to make a number out of the string.</p><pre class="code"><span class="variable">show</span>(<span class="string">&quot;Apollo&quot;</span> + <span class="atom">5</span>);
<span class="variable">show</span>(<span class="atom">null</span> + <span class="string">&quot;ify&quot;</span>);
<span class="variable">show</span>(<span class="string">&quot;5&quot;</span> * <span class="atom">5</span>);
<span class="variable">show</span>(<span class="string">&quot;strawberry&quot;</span> * <span class="atom">5</span>);</pre><p><a class="paragraph" href="#p447d25bd" name="p447d25bd"> ¶ </a>The last statement prints <a name="key86"></a><code>NaN</code>, which is a special value. It stands
for 'not a number', and is of type number (which might sound a little
contradictory). In this case, it refers to the fact that a strawberry
is not a number. All arithmetic operations on the value <code>NaN</code> result
in <code>NaN</code>, which is why multiplying it by <code>5</code>, as in the example, still
gives a <code>NaN</code> value. Also, and this can be disorienting at times, <code>NaN
== NaN</code> equals <code>false</code>, checking whether a value is <code>NaN</code> can be done
with the <a name="key87"></a><code>isNaN</code> function. <code>NaN</code> is another (the last) value that
counts as <code>false</code> when converted to a boolean.</p><p><a class="paragraph" href="#p6ecef1b3" name="p6ecef1b3"> ¶ </a>These automatic conversions can be very convenient, but they are also
rather weird and error prone. Even though <code>+</code> and <code>*</code> are both
arithmetic operators, they behave completely different in the example.
In my own code, I use <code>+</code> to combine strings and non-strings a lot,
but make it a point not to use <code>*</code> and the other numeric operators on
string values. Converting a number to a string is always possible and
straightforward, but converting a string to a number may not even work
(as in the last line of the example). We can use <code>Number</code> to
explicitly convert the string to a number, making it clear that we
might run the risk of getting a <code>NaN</code> value.</p><pre class="code"><span class="variable">show</span>(<span class="variable">Number</span>(<span class="string">&quot;5&quot;</span>) * <span class="atom">5</span>);</pre></div><hr/><div class="block"><p><a class="paragraph" href="#p2a2437b2" name="p2a2437b2"> ¶ </a>When we discussed the boolean operators <code>&amp;&amp;</code> and <code>||</code> earlier, I
claimed they produced boolean values. This turns out to be a bit of an
oversimplification. If you apply them to boolean values, they will
indeed return booleans. But they can also be applied to other kinds of
values, in which case they will return one of their arguments.</p><p><a class="paragraph" href="#p43c2cac3" name="p43c2cac3"> ¶ </a>What <a name="key88"></a><code>||</code> really does is this: It looks at the value to the left of
it first. If converting this value to a boolean would produce <code>true</code>,
it returns this left value, otherwise it returns the one on its
right. Check for yourself that this does the correct thing when the
arguments are booleans. Why does it work like that? It turns out this
is very practical. Consider this example:</p><pre class="code"><span class="keyword">var</span> <span class="variable">input</span> = <span class="variable">prompt</span>(<span class="string">&quot;What is your name?&quot;</span>, <span class="string">&quot;Kilgore Trout&quot;</span>);
<span class="variable">print</span>(<span class="string">&quot;Well hello &quot;</span> + (<span class="variable">input</span> || <span class="string">&quot;dear&quot;</span>));</pre><p><a class="paragraph" href="#p148942a7" name="p148942a7"> ¶ </a>If the user presses 'Cancel' or closes the <code>prompt</code> dialog in some
other way without giving a name, the variable <code>input</code> will hold the
value <code>null</code> or <code>&quot;&quot;</code>. Both of these would give <code>false</code> when converted
to a boolean. The expression <code>input || &quot;dear&quot;</code> can in this case be
read as 'the value of the variable <code>input</code>, or else the string
<code>&quot;dear&quot;</code>'. It is an easy way to provide a 'fallback' value.</p><p><a class="paragraph" href="#p710746e" name="p710746e"> ¶ </a>The <a name="key89"></a><code>&amp;&amp;</code> operator works similarly, but the other way around. When
the value to its left is something that would give <code>false</code> when
converted to a boolean, it returns that value, otherwise it returns
the value on its right.</p><p><a class="paragraph" href="#p74770a64" name="p74770a64"> ¶ </a>Another property of these two operators is that the expression to
their right is only evaluated when necessary. In the case of <code>true ||
X</code>, no matter what <code>X</code> is, the result will be <code>true</code>, so <code>X</code> is never
evaluated, and if it has side effects they never happen. The same goes
for <code>false &amp;&amp; X</code>.</p><pre class="code"><span class="atom">false</span> || <span class="variable">alert</span>(<span class="string">&quot;I'm happening!&quot;</span>);
<span class="atom">true</span> || <span class="variable">alert</span>(<span class="string">&quot;Not me.&quot;</span>);</pre></div><ol class="footnotes"><li><a name="footnote1"></a>Bits are any kinds of two-valued things, usually described as <code>0</code>s
and <code>1</code>s. Inside the computer, they take forms like a high or low
electrical charge, a strong or weak signal, a shiny or dull spot on
the surface of a CD.</li><li><a name="footnote2"></a>If you were expecting something like <code>10010000</code> here ― good call,
but read on. JavaScript's numbers are not stored as integers.</li><li><a name="footnote3"></a>Actually, 53, because of a trick that can be used to get one bit
for free. Look up the 'IEEE 754' format if you are curious about the
details.</li><li><a name="footnote4"></a>When you type string values at the console, you'll notice that they
will come back with the quotes and backslashes the way you typed them.
To get special characters to show properly, you can do <code>print(&quot;a\nb&quot;)</code>
― why this works, we will see in a moment.</li><li><a name="footnote5"></a>The bit bucket is supposedly the place where old bits are kept. On
some systems, the programmer has to manually empty it now and then.
Fortunately, JavaScript comes with a fully-automatic bit-recycling
system.</li></ol><div class="navigation"><a href="chapter1.html">&lt;&lt; Previous chapter</a> | <a href="contents.html">Contents</a> | <a href="index.html">Cover</a> | <a href="chapter3.html">Next chapter &gt;&gt;</a></div><div class="footer">© <a href="mailto:marijnh@gmail.com">Marijn Haverbeke</a> (<a href="http://creativecommons.org/licenses/by/3.0/">license</a>), written March to July 2007, last modified on March 22 2013.</div></div><script type="text/javascript" src="js/mochi.js"> </script><script type="text/javascript" src="js/codemirror.js"> </script><script type="text/javascript" src="js/ejs.js"> </script></body></html>
